<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Text Document Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: monospace; /* Ensures consistent font */
            white-space: pre-wrap; /* Preserves whitespace */
        }
    </style>
</head>
<body>
<pre>
Design an algorithm and develop a C++ Program for the following assignments.
1. To draw line using Digital Differential Analyzer (DDA) algorithm.
#include<iostream.h>
#include<conio.h>
#include<graphics.h>
#include<stdio.h>
#include<dos.h>
#include<math.h>
class DDAL
{
public :
float x,y,x1,y1,x2,y2,l;
int gd,gm,dx,dy,i,xinc,yinc;
void read();
void display();
};
void DDAL :: read()
{
cout<<" Enter the values for x1,y1,x2,y2 : "<<endl;
cin>>x1>>y1>>x2>>y2;
}
void DDAL :: display()
{
dx=abs(x2-x1);
dy=abs(y2-y1);
if(dx>=dy)
{
l=dx;
}
else
{
l=dy;
}
xinc=(x2-x1)/l;
yinc=(y2-y1)/l;
x=x1+0.5;
y=y1+0.5;
i=1;
while(i<=l)
{
putpixel(x,y,30);
x=x+xinc;
y=y+yinc;
i=i+1;
}
getch();
closegraph();
}
void main()
{
int gd,gm;
clrscr();
detectgraph(&gd,&gm);
initgraph(&gd,&gm,"c:\\tc\\BGI");
DDAL d;
d.read();
d.display();
}

Output :
Enter the values for x1, y1, x2, y2 :
100 200
300 200
Display Result :

2. To draw a line using Bresenham’s line drawing algorithm.
#include<iostream.h>
#include<conio.h>
#include<graphics.h>
#include<math.h>
#include<stdio.h>
#include<dos.h>
class BREL
{
public :
float x,y,x1,y1,x2,y2,e,dx,dy;
int gd,gm,i;
void read();
void draw();
};
void BREL :: read()
{
cout<<"Enter the values for x1, y1, x2, y2 : "<<endl;
cin>>x1>>y1>>x2>>y2;
}
void BREL :: draw()
{
detectgraph(&gd, &gm);
initgraph(&gd, &gm, "c:\\tc\\BGI");
dx=abs(x2-x1);
dy=abs(y2-y1);
x=x1;
y=y1;
e=2*dy-dx;
i=1;
do
{
putpixel(x,y,15);
while(e>=0)
{
y=y+1;
e=e-2*dx;
}
x=x+1;
e=e+2*dy;
i=i+1;
}while(i<=dx);
getch();
closegraph();
}
void main()
{
int gd, gm;
detectgraph(&gd, &gm);
initgraph(&gd, &gm, "c:\\tc\\BGI");
BREL b;
b.read();
b.draw();
}
Output :
Enter the values for x1, y1, x2, y2 :
100 200
300 400


Display Result :
3. To draw a circle using Midpoint algorithm. 
#include<iostream.h> 
#include<conio.h> 
#include<graphics.h> 
#include<math.h> 
#include<stdio.h> 
#include<dos.h> 
class MPA 
{ 
public : 
float p; 
int i,gd,gm,x,y,r; 
void read(); 
void draw(); 
}; 
void MPA :: read() 
{ 
cout<<"Enter the Radius of a Circle : "<<endl; 
cin>>r; 
} 
void MPA :: draw() 
{ 
detectgraph(&gd, &gm); 
initgraph(&gd, &gm, "c:\\tc\\BGI"); 
x=0; 
y=r; 
p=1.25-r; 
do 
{ 
putpixel(200+x,200+y,50); 
putpixel(200+y,200+x,50); 
putpixel(200+x,200-y,50); 
putpixel(200+y,200-x,50); 
putpixel(200-x,200-y,50); 
putpixel(200-x,200+y,50); 
putpixel(200-y,200+x,50); 
putpixel(200-y,200-x,50); 
if(p<0) 
{

x=x+1; 
y=y; 
p=p+2*x+1; 
} 
else 
{ 
x=x+1; 
y=y-1; 
p=p+2*(x-y)+1; 
} 
delay(150); 
}while(x<y); 
getch(); 
closegraph(); 
} 
void main() 
{ 
clrscr(); 
MPA m; 
m.read(); 
m.draw(); 
} 


Output :  
Enter the Radius of a Circle : 
50 
Display Result : 

		
4. To draw circle using Bresenham’s line drawing algorithm. 
#include<iostream.h> 
#include<conio.h> 
#include<graphics.h> 
class BLC 
{ 
public : int r,xc,yc,pk,x,y; 
void read(); 
void display(); 
}; 
 
void BLC :: read() 
{ 
cout<<"Enter the center Co-Ordinates XC and YC :"<<endl; 
cin>>xc>>yc; 
cout<<"Enter the Radius of Circle : "<<endl; 
cin>>r; 
} 
void BLC :: display() 
{ 
void drawCircle(int x, int y, int xc, int yc); 
{ 
pk=3-2*r; 
x=0; 
y=r; 
drawCircle(x,y,xc,yc); 
while(x<y) 
{ 
if(pk<=0) 
{ 
pk=pk+(4*x)+6; 
drawCircle(++x,y,xc,yc); 
} 
else 
{ 
pk=pk+(4*(x-y))+10; 
drawCircle(++x,--y,xc,yc); 
} 
}

getch(); 
closegraph(); 
} 
} 
void drawCircle(int x, int y, int xc, int yc) 
{ 
putpixel(x+xc,y+yc,50); 
putpixel(-x+xc,y+yc,50); 
putpixel(x+xc,-y+yc,50); 
putpixel(-x+xc,-y+yc,50); 
putpixel(y+xc,x+yc,50); 
putpixel(y+xc,-x+yc,50); 
putpixel(-y+xc,x+yc,50); 
putpixel(-y+xc,-x+yc,50); 
} 
void main() 
{ 
int gd=DETECT, gm; 
clrscr(); 
initgraph(&gd, &gm, "c:\\tc\\BGI"); 
BLC b; 
clrscr(); 
b.read(); 
b.display(); 
} 
 
Output :  
 Enter the center Co-Ordinates XC and YC : 
 250    300 
 Enter the Radius of Circle : 
 50

5. To draw a simple polygon. 
#include<iostream.h> 
#include<conio.h> 
#include<graphics.h> 
#include<stdio.h> 
#include<math.h> 
class Poly 
{ 
public : int gd, gm, n, x1, y1, x2, y2, x3, y3; 
void read(); 
void display(); 
}; 
void Poly :: read() 
{ 
cout<<"Enter the No. points must greater than 2 "<<endl; 
cin>>n; 
if(n<2) 
{ 
cout<<"Error ! - Please Enter > 2"<<endl; 
} 
else 
{ 
cout<<"Enter the co-ordinates : "<<endl; 
cin>>x1>>y2>>x2>>y2; 
line(x1,y1,x2,y2); 
n=n-2; 
} 
} 
void Poly :: display() 
{ 
while(n>0) 
{ 
if(n>0) 
{ 
cout<<"enter points "<<endl; 
cin>>x3>>y3; 
line(x2,y2,x3,y3); 
x2=x3; 
y2=y3;
n=n-1; 
} 
else 
{ 
line(x2,y2,x1,y1); 
break; 
} 
} 
} 
void main() 
{ 
int gd,gm; 
clrscr(); 
Poly p; 
detectgraph(&gd,&gm); 
initgraph(&gd,&gm,"c:\\tc\\BGI"); 
p.read(); 
p.display(); 
getch(); 
} 
Output :  
Enter the No. points must greater than 2 
6 
Enter the co-ordinates : 
200 200 
350 200 
400 250 
350 300 
200 300 
200 200

Display Result :

6. To draw ellipse using Mid Point algorithm. 
#include<iostream.h> 
#include<conio.h> 
#include<stdlib.h> 
#include<graphics.h> 
class elip 
{ 
public : 
int xc,yc,x,y; float p; long rx,ry; 
void read(); 
void display(); 
}; 
void elip::read() 
{ 
cout<<"Enter Co-Ordinates of centre : "; 
cin>>xc>>yc; 
cout<<"Entr x, y radius of ellipse : "; 
cin>>rx>>ry; 
} 
void elip::display() 
{ 
p=ry*ry-rx*rx*ry+rx*rx/4; 
x=0; 
y=ry; 
while(2.0*ry*ry*x<=2.0*rx*rx*y) 
{ 
if(p<0) 
{ 
x++; 
p=p+2*ry*ry*x+ry*ry; 
} 
else 
{ 
x++;y--; 
p=p+2*ry*ry*x-2*rx*rx*y-ry*ry; 
} 
putpixel(xc+x,yc+y,RED); 
putpixel(xc+x,yc-y,RED); 
putpixel(xc-x,yc+y,RED);
putpixel(xc-x,yc-y,RED); 
} 
p=ry*ry*(x+0.5)*(x+0.5)+rx*rx*(y-1)*(y-1)-rx*rx*ry*ry; 
while(y>0) 
{ 
if(p<=0) 
{ 
x++;y--; 
p=p+2*ry*ry*x-2*rx*rx*y+rx*rx; 
} 
else 
{ 
y--; 
p=p-2*rx*rx*y+rx*rx; 
} 
putpixel(xc+x,yc+y,RED); 
putpixel(xc+x,yc-y,RED); 
putpixel(xc-x,yc+y,RED); 
putpixel(xc-x,yc-y,RED); 
} 
} 
void main() 
{ 
clrscr(); 
elip e; 
int gd=DETECT, gm; 
initgraph(&gd,&gm, "c:\\tc\\BGI"); 
e.read(); 
e.display(); 
getch(); 
closegraph(); 
}

Output :  
Enter Co-Ordinates of centre :   
250 200 
Enter x, y radius of ellipse : 
80 
40 
Display Result :

7. To fill a polygon using Scan line algorithm. 
#include<iostream.h> 
#include<stdlib.h> 
#include<graphics.h> 
#include<conio.h> 
class filpol 
{ 
public : 
int n,i,j,gd,gm,dx,dy,k; 
int x,y,temp; 
int a[20][20],xi[20]; 
float slope[20]; 
void read(); 
void display(); 
}; 
void filpol::read() 
{ 
cout<<"Enter no. of edges of polygon : "<<endl; 
cin>>n; 
cout<<"Enter co-ordinates of polygon "; 
for(i=1;i<=n;i++) 
{ 
cout<<"x["<<i<<"],y["<<i<<"]"<<endl; 
cin>>a[i][0]>>a[i][1]; 
} 
} 
void filpol :: display() 
{ 
a[n][0]=a[0][0]; 
a[n][1]=a[0][1]; 
int gd=DETECT,gm; 
initgraph(&gd,&gm,"c:\\tc\\bgi"); 
for(i=0;i<n;i++) 
{ 
line(a[i][0],a[i][1],a[i+1][0],a[i+1][1]); 
} 
getch(); 
for(i=0;i<n;i++) 
{
dy=a[i+1][1]-a[i][1]; 
dx=a[i+1][0]-a[i][0]; 
if(dy==0)slope[i]=1.0; 
if(dx==0)slope[i]=0.0; 
if((dy!=0)&&(dx!=0)) 
{ 
slope[i]=(float)dx/dy; 
} 
} 
for(y=0;y<480;y++) 
{ 
k=0; 
for(i=0;i<n;i++) 
{ 
if(((a[i][1]<=y)&&(a[i+1][1]>y))||((a[i][1]>y)&&(a[i+1][1]<=y))) 
{ 
xi[k]=(int)(a[i][0]+slope[i]*(y-a[i][1])); 
k++; 
} 
} 
for(j=0;j<k-1;j++) 
for(i=0;i<k-1;i++) 
{ 
if(xi[i]>xi[i+1]) 
{ 
temp=xi[i]; 
xi[i]=xi[i+1]; 
xi[i+1]=temp; 
} 
} 
setcolor(35); 
for(i=0;i<k;i+=2) 
{ 
line(xi[i],y,xi[i+1]+1,y); 
getch(); 
} 
} 
} 
void main()
{ 
filpol fp; 
clrscr(); 
fp.read(); 
fp.display(); 
closegraph(); 
getch(); 
} 


Output :  
Enter no. of edges of Polygon : 
4 
Enter co-ordinates of polygon : 
200 100 
400 100 
200 300 
400 200 
Display Result :

8. To fill a polygon using Boundary fill algorithm. 
#include<iostream.h> 
#include<stdlib.h> 
#include<dos.h> 
#include<graphics.h> 
#include<conio.h> 
class bfp 
{ 
public : void seedfill(int,int,int,int); 
}; 
void bfp :: seedfill(int sx,int sy,int fcol,int bcol) 
{ 
int ccol; 
ccol=getpixel(sx,sy); 
if((ccol!=fcol)&&(ccol!=bcol)) 
{ 
delay(30); 
putpixel(sx,sy,fcol); 
seedfill(sx+1,sy,fcol,bcol); 
seedfill(sx-1,sy,fcol,bcol); 
seedfill(sx,sy+1,fcol,bcol); 
seedfill(sx,sy-1,fcol,bcol); 
} 
} 
void main() 
{ 
bfp p; 
clrscr(); 
int gd,gm,x2,y2,x1,y1; 
detectgraph(&gd,&gm); 
initgraph(&gd,&gm,"c:\\tc\\bgi"); 
cout<<"Enter the co-ordinates : "<<endl; 
cin>>x1>>y1>>x2>>y2; 
rectangle(x1,y1,x2,y2); 
p.seedfill(x1,y1,4,0); 
getch(); 
closegraph(); 
}


Output :  
 Enter the co-ordinates : 
 100 100 
 150 150 
 
 Display Result :

9. To Illustrate the Flood fiil algorithm. 
#include<iostream.h> 
#include<conio.h> 
#include<graphics.h> 
#include<stdlib.h> 
#include<dos.h> 
class ffa 
{ 
public : void floodfill(int,int,int,int); 
}; 
void ffa::floodfill(int sx,int sy,int fcol,int bcol) 
{ 
int ccol; 
ccol=getpixel(sx,sy); 
if(ccol==bcol) 
{ 
delay(10); 
putpixel(sx,sy,fcol); 
floodfill(sx+1,sy,fcol,bcol); 
floodfill(sx-1,sy,fcol,bcol); 
floodfill(sx,sy+1,fcol,bcol); 
floodfill(sx,sy-1,fcol,bcol); 
} 
} 
void main() 
{ 
ffa a; 
clrscr(); 
int gd,gm,x2,y2,x1,y1; 
detectgraph(&gd,&gm); 
initgraph(&gd,&gm,"c:\\tc\\bgi"); 
cout<<"Enter the co-ordinates : "<<endl; 
cin>>x1>>y1>>x2>>y2; 
rectangle(x1,y1,x2,y2); 
a.floodfill(x1+5,y1+5,8,0); 
getch(); 
closegraph(); 
}

Output :  
 Enter the co-ordinates : 
 100 100 
 150 150 
 
 Display Result :


10. To implement Translation on Triangle (2-Dimensional Transformations). 
#include<iostream.h> 
#include<conio.h> 
#include<graphics.h> 
#include<stdlib.h> 
#include<dos.h> 
#include<stdio.h> 
class TT 
{ 
public : 
int x1,y1,x2,y2,x3,y3,tx,ty; 
void read(); 
void display(); 
}; 
void TT :: read() 
{ 
cout<<"Enter the 1st point for triangle : "<<endl; 
cin>>x1>>y1; 
cout<<"Enter the 2nd point for triangle : "<<endl; 
cin>>x2>>y2; 
cout<<"Enter the 3rd point for triangle : "<<endl; 
cin>>x3>>y3; 
cout<<"Enter the Translation Co-Ordinates : "<<endl; 
cin>>tx>>ty; 
} 
void TT :: display() 
{ 
int gd=DETECT, gm; 
initgraph(&gd, &gm, "C:\\TC\\BGI"); 
void DrawTriangle(int,int,int,int,int,int); 
DrawTriangle(x1,y1,x2,y2,x3,y3); 
x1=x1+tx; 
y1=y1+ty; 
x2=x2+tx; 
y2=y2+ty; 
x3=x3+tx; 
y3=y3+ty; 
outtextxy(x1+50,y1,"After Translation "); 
DrawTriangle(x1,y1,x2,y2,x3,y3);
getch(); 
} 
void DrawTriangle(int x1,int y1,int x2,int y2,int x3,int y3) 
{ 
line(x1,y1,x2,y2); 
line(x2,y2,x3,y3); 
line(x3,y3,x1,y1); 
} 
void main() 
{ 
TT t; 
clrscr(); 
int gd,gm; 
detectgraph(&gd,&gm); 
initgraph(&gd,&gm,"c:\\tc\\BGI"); 
t.read(); 
t.display(); 
getch(); 
closegraph(); 
} 


Output :  
Enter the 1st point for triangle : 
260 80 
Enter the 2nd point for triangle : 
340 160 
Enter the 3rd point for triangle : 
180 160 
Enter the Translation Co-Ordinates : 
0 -40 
Display Result :


11. To implement Fixed Point Scaling on Triangle. (2-Dimensional Transformations) 
#include<graphics.h> 
#include<stdlib.h> 
#include<iostream.h> 
#include<conio.h> 
#include<dos.h> 
#include<stdio.h> 
class fpt 
{ 
int x[4],y[4],n; 
void drawtri(int [],int []); 
public : void read(); 
void display(); 
}; 
void fpt :: drawtri(int x[],int y[]) 
{ 
int i; 
moveto(x[0],y[0]); 
for(i=1;i<=n;i++) 
{ 
setcolor(10); 
lineto(x[i],y[i]); 
} 
} 
void fpt::read() 
{ 
int i; 
n=3; 
for(i=0;i<n;i++) 
{ 
cout<<"Enter the vertex x["<<i<<"] , y["<<i<<"]"<<endl; 
cin>>x[i]>>y[i]; 
} 
x[n]=x[0]; 
y[n]=y[0]; 
cleardevice(); 
gotoxy(1,1); 
cout<<"Original Triangle"<<endl; 
drawtri(x,y);
} 
void fpt::display() 
{ 
int xf,yf,i; 
float sx,sy; 
int xr,yr,rx[4],ry[4]; 
cout<<"Enter Scaling Factor"<<endl; 
cin>>sx>>sy; 
cout<<"Enter the fixed points for scaling"<<endl; 
cin>>xf>>yf; 
cout<<"Original Triangle is "<<endl; 
drawtri(x,y); 
cout<<"\t \t After the Scalling is "<<endl; 
for(i=0;i<=n;i++) 
{ 
x[i]=xf+(x[i]-xf)*sx; 
y[i]=yf+(y[i]-yf)*sy; 
} 
drawtri(x,y); 
getch(); 
} 
void main() 
{ 
int gd=DETECT,gm; 
initgraph(&gd,&gm,"c:\\tc\\bgi"); 
cleardevice(); 
fpt f; 
f.read(); 
f.display(); 
getch(); 
}

Output :  
 Enter the vertex x[0] and y[0] : 
 320 240 
 Enter the vertex x[1] and y[1] : 
 240 360 
 Enter the vertex x[2] and y[2] : 
 400 360 
 Enter Scaling Factor : 
 0.4 0.5 
 Enter the fixed points for scaling  : 
 320 240 
 
 Display Result : 
 
 Original Triangle is :                                                       After the Scaling is :


12. To implement Pivot Point Rotation on Triangle. (2-Dimensional  
Transformations) 
#include<graphics.h> 
#include<stdlib.h> 
#include<iostream.h> 
#include<conio.h> 
#include<math.h> 
#include<stdio.h> 
class ppr 
{ 
int x[4],y[4],n; 
void drawtri(int [],int []); 
public : void read(); 
void display(); 
}; 
void ppr :: drawtri(int x[],int y[]) 
{ 
int i; 
moveto(x[0],y[0]); 
for(i=1;i<=n;i++) 
{ 
setcolor(10); 
lineto(x[i],y[i]); 
} 
} 
void ppr::read() 
{ 
int i; 
n=3; 
for(i=0;i<n;i++) 
{ 
cout<<"Enter the vertex x["<<i<<"] , y["<<i<<"]"<<endl; 
cin>>x[i]>>y[i]; 
} 
x[n]=x[0]; 
y[n]=y[0]; 
cleardevice(); 
gotoxy(1,1); 
cout<<"Original Triangle"<<endl;
drawtri(x,y); 
} 
void ppr::display() 
{ 
int xr,yr,i,theta; 
float tet; 
int rx[4],ry[4]; 
cout<<"Enter Rotation angle"<<endl; 
cin>>theta; 
tet=(theta*(3.14/180.0)); 
cout<<"Enter the points for Rotation"<<endl; 
cin>>xr>>yr; 
cout<<"After the Rotation is "<<endl; 
for(i=0;i<=n;i++) 
{ 
rx[i]=xr+(x[i]-xr)*cos(tet)-(y[i]-yr)*sin(tet); 
ry[i]=yr+(y[i]-yr)*cos(tet)-(x[i]-xr)*sin(tet); 
} 
drawtri(rx,ry); 
getch(); 
} 
void main() 
{ 
int gd=DETECT,gm; 
initgraph(&gd,&gm,"c:\\tc\\bgi"); 
cleardevice(); 
ppr f; 
f.read(); 
f.display(); 
getch(); 
}

Output :  
 Enter the vertex x[0] and y[0] : 
 320 240 
 Enter the vertex x[1] and y[1] : 
 240 360 
 Enter the vertex x[2] and y[2] : 
 400 360 
 Enter rotation angle : 
 900 
 Enter the points for rotation  : 
 320 240 
 
13. To implement 2D Composition transformations. 
#include<iostream.h> 
#include<conio.h> 
#include<math.h> 
#include<graphics.h> 
void main() 
{ 
int gd,gm; 
float sx,sy,i,fx,fy,x[10],y[10],tx,ty; 
clrscr(); 
detectgraph(&gd,&gm); 
initgraph(&gd,&gm,"c:\\tc\\bgi"); 
line(320,0,320,480); 
line(0,240,640,240); 
outtextxy(320,240,"(0,0)"); 
cout<<"Enter the Co-ordinates"<<endl; 
for(i=0;i<3;i++) 
{ 
cin>>x[i]>>y[i]; 
} 
line(x[1]+320,y[1]+240,x[2]+320,y[2]+240); 
line(x[2]+320,y[2]+240,x[3]+320,y[3]+240); 
line(x[3]+320,y[3]+240,x[1]+320,y[1]+240); 
cout<<"Enter Scaling Factors"<<endl; 
cin>>sx>>sy; 
cout<<"Enter the fixed points"<<endl; 
cin>>fx>>fy; 
setcolor(15); 
line(x[1]*sx+fx*(1-sx)+320,y[1]*sy+fy*(1-sy)+240,x[2]*sx+fx*(1-sx)+320,y[2]*sy+fy*(1
sy)+240); 
line(x[2]*sx+fx*(1-sx)+320,y[2]*sy+fy*(1-sy)+240,x[3]*sx+fx*(1-sx)+320,y[3]*sy+fy*(1
sy)+240); 
line(x[3]*sx+fx*(1-sx)+320,y[3]*sy+fy*(1-sy)+240,x[1]*sx+fx*(1-sx)+320,y[1]*sy+fy*(1
sy)+240); 
getch(); 
cout<<"Enter the translation"<<endl; 
cin>>tx>>ty; 
line((x[1]*sx+fx*(1-sx)+320)+tx,(y[1]*sy+fy*(1-sy)+240)+ty,(x[2]*sx+fx*(1
sx)+320)+tx,(y[2]*sy+fy*(1-sy)+240)+ty);
line((x[2]*sx+fx*(1-sx)+320)+tx,(y[2]*sy+fy*(1-sy)+240)+ty,(x[3]*sx+fx*(1
sx)+320)+tx,(y[3]*sy+fy*(1-sy)+240)+ty); 
line((x[3]*sx+fx*(1-sx)+320)+tx,(y[3]*sy+fy*(1-sy)+240)+ty,(x[1]*sx+fx*(1
sx)+320)+tx,(y[1]*sy+fy*(1-sy)+240)+ty); 
getch(); 
}


Output :  
 Enter the Co-Ordinates : 
 50 50 
 100 50 
 150 200 
 Enter Scaling Factors : 
 0.2 0.2 
 Enter the Fixed points : 
 100 100 
 Enter the translation : 
 15 15 
 
 Display Result :


14. To implement 3-Dimensional Translation Transformation on Cube. 
#include<iostream.h> 
#include<conio.h> 
#include<graphics.h> 
#include<math.h> 
int midx,midy,o,maxx,maxy; 
void axis() 
{ 
line(midx,0,midx,maxy); 
line(0,midy,maxx,midy); 
cleardevice(); 
getch(); 
} 
void main() 
{ 
int gd,gm,x,y,z,o,x1,y1,x2,y2; 
int maxx,maxy,midx,midy; 
detectgraph(&gd,&gm); 
initgraph(&gd,&gm,"c:\\tc\\bgi"); 
line(320,0,320,480); 
line(0,240,640,240); 
outtextxy(320,240,"(0,0)"); 
setfillstyle(0,getmaxcolor()); 
maxx=getmaxx(); 
maxy=getmaxy(); 
midx=maxx/2; 
midy=maxy/2; 
bar3d(midx+100,midy-150,midx+60,midy-100,10,1); 
cout<<"Enter the translation factor "<<endl; 
cin>>x>>y; 
cout<<"After Translation"<<endl; 
bar3d(midx+100,midy-150,midx+60,midy-100,10,1); 
bar3d(midx+x+100,midy-(y+150),midx+x+60,midy-(y+100),10,1); 
getch(); 
closegraph(); 
}


Output :  
 Enter the translation factor : 
 -260 -260 
 
 Display Result : 


15. To implement 3-Dimensional scaling transformation on Cube. 
#include<iostream.h> 
#include<conio.h> 
#include<graphics.h> 
#include<math.h> 
int midx,midy,o,maxx,maxy; 
void axis() 
{ 
line(midx,0,midx,maxy); 
line(0,midy,maxx,midy); 
cleardevice(); 
getch(); 
} 
void main() 
{ 
int gd,gm,x,y,z,o,x1,y1,x2,y2; 
int maxx,maxy,midx,midy; 
detectgraph(&gd,&gm); 
initgraph(&gd,&gm,"c:\\tc\\bgi"); 
line(320,0,320,480); 
line(0,240,640,240); 
outtextxy(320,240,"(0,0)"); 
setfillstyle(0,getmaxcolor()); 
maxx=getmaxx(); 
maxy=getmaxy(); 
midx=maxx/2; 
midy=maxy/2; 
bar3d(midx+100,midy-150,midx+60,midy-100,10,1); 
cout<<"Enter the translation factor "<<endl; 
cin>>x>>y>>z; 
cout<<"After Translation"<<endl; 
bar3d(midx+100,midy-150,midx+60,midy-100,10,1); 
bar3d(midx+(x*100),midy-(y*150),midx+(x*60),midy-(y*100),10*z,1); 
getch(); 
closegraph(); 
}

Output :  
 Enter the Scaling factor : 
 -1 2 3 
 
 Display Result :


16. To convert from HSV to RGB. 
#include<iostream.h> 
#include<conio.h> 
#include<graphics.h> 
#include<math.h> 
void hsvtorgb(float h,float s,float v) 
{ 
float *r,*g,*b; 
int i; 
float aa,bb,cc,f; 
if(s==0) 
{ 
*r=*g=*b=v; 
} 
else 
{ 
if(h==1.0) 
h=0; 
h*=6.0; 
i=floor(h); 
f=h-i; 
aa=v*(1-s); 
bb=v*(1-(s*f)); 
cc=v*(1-(s*(1-f))); 
switch(i) 
{ 
case 0:*r=v; *g=cc; *b=aa; 
cout<<"R= "<<*r<<endl<<"G= "<<*g<<endl<<"B= "<<*b<<endl; 
break; 
case 1:*r=bb; *g=v; *b=aa; 
cout<<"R= "<<*r<<endl<<"G= "<<*g<<endl<<"B= "<<*b<<endl; 
break; 
case 3:*r=aa; *g=bb; *b=v; 
cout<<"R= "<<*r<<endl<<"G= "<<*g<<endl<<"B= "<<*b<<endl; 
break; 
case 4:*r=cc; *g=aa; *b=v; 
cout<<"R= "<<*r<<endl<<"G= "<<*g<<endl<<"B= "<<*b<<endl; 
break; 
case 5:*r=v; *g=aa; *b=bb;
cout<<"R= "<<*r<<endl<<"G= "<<*g<<endl<<"B= "<<*b<<endl; 
break; 
} 
} 
} 
void main() 
{ 
float a,b,c; 
clrscr(); 
cout<<"Enter the HSV values in Between 0 to 3 :"<<endl; 
cin>>a>>b>>c;  
cout<<"RGB Values are"<<endl; 
hsvtorgb(a,b,c); 
getch(); 
} 

Output :  
Enter the HSV values in Between 0 to 3 : 
1 
0.5 
0.5 
RGB values are : 
R = 0.5 
G = 0.25 
B = 0.25



17. To convert from RGB to HSV. 
#include<iostream.h> 
#include<conio.h> 
#include<math.h> 
float max(float a,float b, float c) 
{ 
return ((a>b)? (a>c?a:c):(b>c?b:c)); 
} 
float min(float a,float b, float c) 
{ 
return ((a<b)? (a<c?a:c):(b<c?b:c)); 
} 
void rgbtohsv(float r,float g,float b) 
{ 
float h,s,v; 
r/=255.0; 
g/=255.0; 
b/=255.0; 
float cmax=max(r,g,b); 
float cmin=min(r,g,b); 
float diff=cmax=cmin; 
if(cmax==cmin) 
h=0; 
else if(cmax==r) 
h=fmod((60*((g-b)/diff)+360),360.0); 
else if(cmax==g) 
h=fmod((60*((b-r)/diff)+120),360.0); 
else if(cmax==b) 
h=fmod((60*((r-g)/diff)+240),360.0); 
if(cmax==0) 
s=0; 
else 
s=(diff/cmax)*100; 
v=cmax*100; 
cout<<"H= "<<h<<endl<<"S= "<<s<<endl<<"V= "<<v<<endl; 
} 
void main() 
{ 
float r,g,b;
clrscr(); 
cout<<"Enter R G B values"<<endl; 
cin>>r>>g>>b; 
cout<<"HSV values are"<<endl; 
rgbtohsv(r,g,b); 
getch(); 
} 

Output :  
Enter the RGB values : 
1 
0.5 
0.7 
HSV values are : 
H = 366.0 
S = 50.0 
V = 0.4


18. To animating the rolling ball on a flat surface. 
#include<iostream.h> 
#include<conio.h> 
#include<graphics.h> 
#include<math.h> 
#include<dos.h> 
#define pi-22.0/(7*90) 
class ball 
{ 
int x,y,ra; 
public : void needle(int,int,int); 
}; 
void ball :: needle(int cx,int cy,int r) 
{ 
int x,y,x1,y1,t1=0,nx; 
float dx,dy,p,t=0.0,q; 
x=0; 
y=-r; 
while(!kbhit()) 
{ 
q=t*pi; 
nx=cx+t; 
dx=x*cos(q)+y*sin(q)+nx; 
dy=y*cos(q)-x*sin(q)+cy; 
x1=ceil(dx); 
y1=ceil(dy); 
setcolor(YELLOW); 
line(nx,cy,x1,y1); 
setcolor(RED); 
circle(nx,cy,50); 
t1+=3; 
t+=2; 
if(t>=360) 
t=0; 
delay(20); 
setcolor(0); 
circle(nx,cy,50); 
line(nx,cy,x1,y1); 
}
getch(); 
} 
void main() 
{ 
int dr=DETECT,dm; 
clrscr(); 
initgraph(&dr,&dm,"c:\\tc\\BGI"); 
ball a; 
settextstyle(1,0,5); 
outtextxy(100,100,"Rolling of a Ball"); 
outtextxy(110,125,"-----------------"); 
moveto(50,301); 
lineto(500,301); 
setcolor(0); 
a.needle(0,250,50); 
getch(); 
closegraph(); 
}


19. To demonstrate the revolution of earth around the sun and moon. 
#include<iostream.h> 
#include<conio.h> 
#include<graphics.h> 
#include<math.h> 
#include<dos.h> 
class rev 
{ 
float x,y,x1,y1,x2,y2; 
public : void draw(void); 
}; 
void rev::draw() 
{ 
static int th,th1; 
x=320; 
y=240; 
float pi=3.142/180; 
while(!kbhit()) 
{ 
outtextxy(10,10,"Moon around the Earth and Earth around the Sun."); 
setcolor(WHITE); 
setcolor(RED); 
circle(x,y,50); 
outtextxy(x-10,y-15,"SUN"); 
th1+=1; 
th+=20; 
x1=x+165*sin(th1*pi); 
y1=y+165*cos(th1*pi); 
x2=x1+70*sin(th*pi); 
y2=y1+70*cos(th*pi); 
setcolor(BLUE); 
circle(x1,y1,30); 
setcolor(7); 
circle(x2,y2,10); 
outtextxy(x1-18,y1-15,"EARTH"); 
outtextxy(x2-17,y2-18,"MOON"); 
if(th1>=360) 
{th=0; 
th1=0;
} 
delay(200); 
clearviewport(); 
} 
} 
void main() 
{ 
int gd=DETECT,gm; 
initgraph(&gd,&gm,"c:\\tc\\bgi"); 
rev r; 
r.draw(); 
setcolor(WHITE); 
getch(); 
closegraph(); 
} 


Output :   
Moon around the Earth and Earth around the Sun.



20. To animate the oscillation of a pendulum. 
#include<iostream.h> 
#include<conio.h> 
#include<graphics.h> 
#include<math.h> 
#include<dos.h> 
int x1=300,y1=180,x,y; 
void display(double i) 
{ 
circle(300,130,50); 
line(210,60,210,320); 
line(210,60,390,60); 
line(210,320,390,320); 
line(390,60,390,320); 
outtextxy(295,88,"12"); 
outtextxy(260,130,"9"); 
outtextxy(340,130,"3"); 
outtextxy(295,168,"6"); 
line(300,130,300,98); 
line(300,98,297,101); 
line(300,98,303,101); 
line(337,130,300,130); 
line(337,130,334,127); 
line(337,130,334,133); 
x=x1+95*cos(i); 
y=y1+95*sin(i); 
line(x1,y1,x,y); 
circle(x,y,10); 
delay(5); 
clearviewport(); 
} 
void main() 
{ 
int gd=DETECT,gm; 
double i; 
initgraph(&gd,&gm,"c:\\tc\\bgi"); 
while(!kbhit()) 
{ 
for(i=2;i>1;i=i-0.01)
display(i); 
for(i=1;i<2;i=i+0.01) 
display(i); 
} 
getch(); 
}

Output :

21. To animate the walking of a man. 
#include<stdio.h> 
#include<conio.h> 
#include<graphics.h> 
#include<dos.h> 
void main() 
{ 
int gd=DETECT,gm,i; 
int x1=100,t1=x1-30,t2=x1+30; 
int a1=t1,a2=t2; 
initgraph(&gd,&gm,"c:\\tc\\bgi"); 
for(i=0;i<30;i++) 
{ 
for(;t1<x1+30&&t2>x1-30;t1++,x1++,t2--) 
{ 
delay(30); 
clrscr(); 
line(0,310,1366,310); 
circle(x1,100,30); 
line(x1,130,x1,220); 
line(x1,150,a1=a1+5,200); 
line(x1,150,a2=a2-3,200); 
line(x1,220,t1=t1+4,310); 
line(x1,220,t2=t2-2,310); 
} 
t1=x1-30;t2=x1+30;a1=t1;a2=t2; 
} 
getch(); 
} 

Output :

</pre>
</body>
</html>
